# -*- coding: utf-8 -*-
"""IA sin librerias.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AllNYH1V2TKb_FUIkSyL4cWQynQzoVVH
"""

from google.colab import files
files.upload()

def leer_csv(ruta):
    with open(ruta, "r", encoding="utf-8") as archivo:
        lineas = archivo.readlines()

    encabezados = lineas[0].strip().split(",")
    datos = [linea.strip().split(",") for linea in lineas[1:]]
    return encabezados, datos

def escribir_csv(ruta, encabezados, datos):
    with open(ruta, "w", encoding="utf-8") as archivo:
        archivo.write(",".join(encabezados) + "\n")
        for fila in datos:
            archivo.write(",".join(str(d) for d in fila) + "\n")

import random

def dividir_dataset(datos, fraccion_train, fraccion_val):
    random.shuffle(datos)  # mezcla aleatoriamente los datos

    total = len(datos)
    tam_train = int(total * fraccion_train)
    tam_val = int(total * fraccion_val)

    train = datos[:tam_train]
    val = datos[tam_train:tam_train + tam_val]
    test = datos[tam_train + tam_val:]

    return train, val, test

def eliminar_columnas(encabezados, datos, columnas_a_eliminar):
    indices = [encabezados.index(col) for col in columnas_a_eliminar if col in encabezados]


    # elimina de encabezados
    nuevos_encabezados = [col for i, col in enumerate(encabezados) if i not in indices]

    # elimina de datos
    nuevos_datos = []
    for fila in datos:
        nueva_fila = [valor for i, valor in enumerate(fila) if i not in indices]
        nuevos_datos.append(nueva_fila)

    return nuevos_encabezados, nuevos_datos

def es_numero(valor): # para la funcion normalizar y rellenar nulos
    try:
        float(valor)
        return True
    except:
        return False

def normalizar_numericos(encabezados, datos):
    # transponer datos para trabajar por columnas
    columnas = list(zip(*datos))
    columnas_normalizadas = []

    for i, col in enumerate(columnas):
        if all(es_numero(v) for v in col):
            # convertir a float
            col_float = [float(v) for v in col]
            min_val = min(col_float)
            max_val = max(col_float)
            rango = max_val - min_val if max_val != min_val else 1

            # normalizar
            col_norm = [str((v - min_val) / rango) for v in col_float]
            columnas_normalizadas.append(col_norm)
        else:
            # no es numerica se queda igual
            columnas_normalizadas.append(col)

    # volver a formar las filas normalizadas
    datos_normalizados = list(map(list, zip(*columnas_normalizadas)))
    return encabezados, datos_normalizados

def codificar_categorias(encabezados, datos):
    print("→ Codificando variables categóricas...")
    codificaciones = {}

    for i, nombre_columna in enumerate(encabezados):
        # revisa si la columna contiene texto (no numerico)
        if not all(es_numero(fila[i]) for fila in datos):
            print(f"Columna '{nombre_columna}' es categórica.")

            # crear un mapeo de texto a numero
            valores_unicos = list(set(fila[i] for fila in datos))
            mapeo = {valor: str(indice) for indice, valor in enumerate(valores_unicos)}
            codificaciones[nombre_columna] = mapeo

            for fila in datos:
                fila[i] = mapeo[fila[i]]

            print(f"→ Mapeo: {mapeo}")

    print("→ Codificación completada.")
    return encabezados, datos

def rellenar_nulos(encabezados, datos):
    columnas = list(zip(*datos))
    columnas_procesadas = []

    for i, col in enumerate(columnas):
        if all(es_numero(v) or v == "" for v in col):
            # columna numerica: calcular media ignorando vacios
            valores = [float(v) for v in col if v != ""]
            media = sum(valores) / len(valores) if valores else 0
            nueva_col = [str(media) if v == "" else v for v in col]
        else:
            # columna de texto: rellenar vacios con "Desconocido"
            nueva_col = ["Desconocido" if v == "" else v for v in col]

        columnas_procesadas.append(nueva_col)

    # reconstruir las filas
    datos_rellenados = list(map(list, zip(*columnas_procesadas)))
    return encabezados, datos_rellenados

#leer el archivo CSV desde la pc
encabezados, datos = leer_csv("high_popularity_spotify_data.csv")

#eliminar columnas no deseadas (por ejemplo, eliminar columna "id" y "url")
columnas_a_eliminar = ["id", "url"]
encabezados, datos = eliminar_columnas(encabezados, datos, columnas_a_eliminar)

#rellenar valores nulos (usando 'Desconocido' o media para numéricos)
encabezados, datos = rellenar_nulos(encabezados, datos)

#codificar categorías (convertir texto en nimeros)
encabezados, datos = codificar_categorias(encabezados, datos)

#normalizar columnas numericas (valores entre 0 y 1)
encabezados, datos = normalizar_numericos(encabezados, datos)

#dividir en entrenamiento, validacion y prueba
train, val, test = dividir_dataset(datos, 0.7, 0.15)  # 70% train, 15% val, 15% test

#guardar los nuevos datasets
escribir_csv("entrenamiento.csv", encabezados, train)
escribir_csv("validacion.csv", encabezados, val)
escribir_csv("prueba.csv", encabezados, test)